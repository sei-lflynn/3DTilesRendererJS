import{L as z,r as Z,F as J,B as q,a as Y,g as K}from"./BatchTable-CRr3zuRk.js";import{aY as X,k as y,l as u,bk as tt,Q as v}from"./three.module-D9WYbBBL.js";import{G as et}from"./GLTFLoader-CFPJuhhp.js";import{E as st}from"./Ellipsoid-DWeM2IpF.js";const lt=-1,Tt=0,ht=1,gt=2,pt=3,G=6378137,at=6356752314245179e-9;class nt extends z{parse(o){const a=new DataView(o),s=Z(a);console.assert(s==="i3dm");const N=a.getUint32(4,!0);console.assert(N===1);const S=a.getUint32(8,!0);console.assert(S===o.byteLength);const A=a.getUint32(12,!0),b=a.getUint32(16,!0),c=a.getUint32(20,!0),L=a.getUint32(24,!0),f=a.getUint32(28,!0),g=32,M=o.slice(g,g+A+b),n=new J(M,0,A,b),e=g+A+b,T=o.slice(e,e+c+L),m=new q(T,n.getData("INSTANCES_LENGTH"),0,c,L),E=e+c+L,p=new Uint8Array(o,E,S-E);let d=null,h=null,U=null;if(f)d=p,h=Promise.resolve();else{const r=this.resolveExternalURL(Y(p));U=K(r),h=fetch(r,this.fetchOptions).then(i=>{if(!i.ok)throw new Error(`I3DMLoaderBase : Failed to load file "${r}" with status ${i.status} : ${i.statusText}`);return i.arrayBuffer()}).then(i=>{d=new Uint8Array(i)})}return h.then(()=>({version:N,featureTable:n,batchTable:m,glbBytes:d,gltfWorkingPath:U}))}}const Q=new st(G,G,at);Q.name="WGS84 Earth";const W=new u,R=new u,D=new u,C=new u,F=new v,w=new u,I=new y,H=new y,V=new u,k=new y,P=new v,x={};class ut extends nt{constructor(o=X){super(),this.manager=o,this.adjustmentTransform=new y,this.ellipsoid=Q.clone()}resolveExternalURL(o){return this.manager.resolveURL(super.resolveExternalURL(o))}parse(o){return super.parse(o).then(a=>{const{featureTable:s,batchTable:N}=a,S=a.glbBytes.slice().buffer;return new Promise((A,b)=>{const c=this.fetchOptions,L=this.manager,f=L.getHandler("path.gltf")||new et(L);c.credentials==="include"&&c.mode==="cors"&&f.setCrossOrigin("use-credentials"),"credentials"in c&&f.setWithCredentials(c.credentials==="include"),c.headers&&f.setRequestHeader(c.headers);let g=a.gltfWorkingPath??this.workingPath;/[\\/]$/.test(g)||(g+="/");const M=this.adjustmentTransform;f.parse(S,g,n=>{const e=s.getData("INSTANCES_LENGTH"),T=s.getData("POSITION",e,"FLOAT","VEC3"),m=s.getData("NORMAL_UP",e,"FLOAT","VEC3"),E=s.getData("NORMAL_RIGHT",e,"FLOAT","VEC3"),p=s.getData("SCALE_NON_UNIFORM",e,"FLOAT","VEC3"),d=s.getData("SCALE",e,"FLOAT","SCALAR"),h=s.getData("RTC_CENTER",1,"FLOAT","VEC3"),U=s.getData("EAST_NORTH_UP");["QUANTIZED_VOLUME_OFFSET","QUANTIZED_VOLUME_SCALE","POSITION_QUANTIZED","NORMAL_UP_OCT32P","NORMAL_RIGHT_OCT32P"].forEach(t=>{t in s.header&&console.warn(`I3DMLoader: Unsupported FeatureTable feature "${t}" detected.`)});const r=new u;for(let t=0;t<e;t++)r.x+=T[t*3+0]/e,r.y+=T[t*3+1]/e,r.z+=T[t*3+2]/e;const i=[],B=[];n.scene.updateMatrixWorld(),n.scene.traverse(t=>{if(t.isMesh){B.push(t);const{geometry:O,material:_}=t,l=new tt(O,_,e);l.position.copy(r),h&&(l.position.x+=h[0],l.position.y+=h[1],l.position.z+=h[2]),i.push(l)}});for(let t=0;t<e;t++){C.set(T[t*3+0]-r.x,T[t*3+1]-r.y,T[t*3+2]-r.z),F.identity(),m&&(R.set(m[t*3+0],m[t*3+1],m[t*3+2]),D.set(E[t*3+0],E[t*3+1],E[t*3+2]),W.crossVectors(D,R).normalize(),I.makeBasis(D,R,W),F.setFromRotationMatrix(I)),w.set(1,1,1),p&&w.set(p[t*3+0],p[t*3+1],p[t*3+2]),d&&w.multiplyScalar(d[t]);for(let O=0,_=i.length;O<_;O++){const l=i[O];P.copy(F),U&&(l.updateMatrixWorld(),V.copy(C).applyMatrix4(l.matrixWorld),this.ellipsoid.getPositionToCartographic(V,x),this.ellipsoid.getEastNorthUpFrame(x.lat,x.lon,k),P.setFromRotationMatrix(k)),I.compose(C,P,w).multiply(M);const j=B[O];H.multiplyMatrices(I,j.matrixWorld),l.setMatrixAt(t,H)}}n.scene.clear(),n.scene.add(...i),n.batchTable=N,n.featureTable=s,n.scene.batchTable=N,n.scene.featureTable=s,A(n)},b)})})}}export{lt as F,ut as I,pt as L,gt as P,Tt as U,Q as W,G as a,ht as b};
//# sourceMappingURL=I3DMLoader-BeHz4bWV.js.map
